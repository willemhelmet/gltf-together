/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * The root object for a glTF asset.
 */
export type GlTF = GlTFProperty & {
  /**
   * Names of glTF extensions used in this asset.
   *
   * @minItems 1
   */
  extensionsUsed?: [string, ...string[]];
  /**
   * Names of glTF extensions required to properly load this asset.
   *
   * @minItems 1
   */
  extensionsRequired?: [string, ...string[]];
  /**
   * An array of accessors.
   *
   * @minItems 1
   */
  accessors?: [Accessor, ...Accessor[]];
  /**
   * An array of keyframe animations.
   *
   * @minItems 1
   */
  animations?: [Animation, ...Animation[]];
  /**
   * Metadata about the glTF asset.
   */
  asset: Asset;
  /**
   * An array of buffers.
   *
   * @minItems 1
   */
  buffers?: [Buffer, ...Buffer[]];
  /**
   * An array of bufferViews.
   *
   * @minItems 1
   */
  bufferViews?: [BufferView, ...BufferView[]];
  /**
   * An array of cameras.
   *
   * @minItems 1
   */
  cameras?: [Camera, ...Camera[]];
  /**
   * An array of images.
   *
   * @minItems 1
   */
  images?: [Image, ...Image[]];
  /**
   * An array of materials.
   *
   * @minItems 1
   */
  materials?: [Material, ...Material[]];
  /**
   * An array of meshes.
   *
   * @minItems 1
   */
  meshes?: [Mesh, ...Mesh[]];
  /**
   * An array of nodes.
   *
   * @minItems 1
   */
  nodes?: [Node, ...Node[]];
  /**
   * An array of samplers.
   *
   * @minItems 1
   */
  samplers?: [Sampler, ...Sampler[]];
  /**
   * The index of the default scene.
   */
  scene?: GlTFId;
  /**
   * An array of scenes.
   *
   * @minItems 1
   */
  scenes?: [Scene, ...Scene[]];
  /**
   * An array of skins.
   *
   * @minItems 1
   */
  skins?: [Skin, ...Skin[]];
  /**
   * An array of textures.
   *
   * @minItems 1
   */
  textures?: [Texture, ...Texture[]];
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
};
/**
 * A typed view into a buffer view that contains raw binary data.
 */
export type Accessor = GlTFChildOfRootProperty & {
  /**
   * The index of the bufferView.
   */
  bufferView?: GlTFId;
  /**
   * The offset relative to the start of the buffer view in bytes.
   */
  byteOffset?: number;
  /**
   * The datatype of the accessor's components.
   */
  componentType: 5120 | 5121 | 5122 | 5123 | 5125 | 5126 | number;
  /**
   * Specifies whether integer data values are normalized before usage.
   */
  normalized?: boolean;
  /**
   * The number of elements referenced by this accessor.
   */
  count: number;
  /**
   * Specifies if the accessor's elements are scalars, vectors, or matrices.
   */
  type: "SCALAR" | "VEC2" | "VEC3" | "VEC4" | "MAT2" | "MAT3" | "MAT4" | string;
  /**
   * Maximum value of each component in this accessor.
   *
   * @minItems 1
   * @maxItems 16
   */
  max?:
    | [number]
    | [number, number]
    | [number, number, number]
    | [number, number, number, number]
    | [number, number, number, number, number]
    | [number, number, number, number, number, number]
    | [number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number, number, number, number, number]
    | [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
      ]
    | [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
      ];
  /**
   * Minimum value of each component in this accessor.
   *
   * @minItems 1
   * @maxItems 16
   */
  min?:
    | [number]
    | [number, number]
    | [number, number, number]
    | [number, number, number, number]
    | [number, number, number, number, number]
    | [number, number, number, number, number, number]
    | [number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number, number, number, number, number]
    | [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
      ]
    | [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
      ];
  /**
   * Sparse storage of elements that deviate from their initialization value.
   */
  sparse?: AccessorSparse;
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
} & {
  /**
   * The index of the bufferView.
   */
  bufferView?: GlTFId;
  /**
   * The offset relative to the start of the buffer view in bytes.
   */
  byteOffset?: number;
  /**
   * The datatype of the accessor's components.
   */
  componentType: 5120 | 5121 | 5122 | 5123 | 5125 | 5126 | number;
  /**
   * Specifies whether integer data values are normalized before usage.
   */
  normalized?: boolean;
  /**
   * The number of elements referenced by this accessor.
   */
  count: number;
  /**
   * Specifies if the accessor's elements are scalars, vectors, or matrices.
   */
  type: "SCALAR" | "VEC2" | "VEC3" | "VEC4" | "MAT2" | "MAT3" | "MAT4" | string;
  /**
   * Maximum value of each component in this accessor.
   *
   * @minItems 1
   * @maxItems 16
   */
  max?:
    | [number]
    | [number, number]
    | [number, number, number]
    | [number, number, number, number]
    | [number, number, number, number, number]
    | [number, number, number, number, number, number]
    | [number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number, number, number, number, number]
    | [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
      ]
    | [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
      ];
  /**
   * Minimum value of each component in this accessor.
   *
   * @minItems 1
   * @maxItems 16
   */
  min?:
    | [number]
    | [number, number]
    | [number, number, number]
    | [number, number, number, number]
    | [number, number, number, number, number]
    | [number, number, number, number, number, number]
    | [number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number, number, number, number, number]
    | [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
      ]
    | [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
      ];
  /**
   * Sparse storage of elements that deviate from their initialization value.
   */
  sparse?: AccessorSparse;
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
};
export type GlTFChildOfRootProperty = GlTFProperty & {
  /**
   * The user-defined name of this object.
   */
  name?: string;
  [k: string]: unknown;
} & {
  /**
   * The user-defined name of this object.
   */
  name?: string;
  [k: string]: unknown;
} & {
  /**
   * The user-defined name of this object.
   */
  name?: string;
  [k: string]: unknown;
} & {
  /**
   * The user-defined name of this object.
   */
  name?: string;
  [k: string]: unknown;
} & {
  /**
   * The user-defined name of this object.
   */
  name?: string;
  [k: string]: unknown;
} & {
  /**
   * The user-defined name of this object.
   */
  name?: string;
  [k: string]: unknown;
} & {
  /**
   * The user-defined name of this object.
   */
  name?: string;
  [k: string]: unknown;
} & {
  /**
   * The user-defined name of this object.
   */
  name?: string;
  [k: string]: unknown;
} & {
  /**
   * The user-defined name of this object.
   */
  name?: string;
  [k: string]: unknown;
} & {
  /**
   * The user-defined name of this object.
   */
  name?: string;
  [k: string]: unknown;
} & {
  /**
   * The user-defined name of this object.
   */
  name?: string;
  [k: string]: unknown;
} & {
  /**
   * The user-defined name of this object.
   */
  name?: string;
  [k: string]: unknown;
} & {
  /**
   * The user-defined name of this object.
   */
  name?: string;
  [k: string]: unknown;
};
export type GlTFId = number;
/**
 * Sparse storage of accessor values that deviate from their initialization value.
 */
export type AccessorSparse = GlTFProperty & {
  /**
   * Number of deviating accessor values stored in the sparse array.
   */
  count: number;
  /**
   * An object pointing to a buffer view containing the indices of deviating accessor values. The number of indices is equal to `count`. Indices **MUST** strictly increase.
   */
  indices: AccessorSparseIndices;
  /**
   * An object pointing to a buffer view containing the deviating accessor values.
   */
  values: AccessorSparseValues;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
};
/**
 * An object pointing to a buffer view containing the indices of deviating accessor values. The number of indices is equal to `accessor.sparse.count`. Indices **MUST** strictly increase.
 */
export type AccessorSparseIndices = GlTFProperty & {
  /**
   * The index of the buffer view with sparse indices. The referenced buffer view **MUST NOT** have its `target` or `byteStride` properties defined. The buffer view and the optional `byteOffset` **MUST** be aligned to the `componentType` byte length.
   */
  bufferView: GlTFId;
  /**
   * The offset relative to the start of the buffer view in bytes.
   */
  byteOffset?: number;
  /**
   * The indices data type.
   */
  componentType: 5121 | 5123 | 5125 | number;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
};
/**
 * An object pointing to a buffer view containing the deviating accessor values. The number of elements is equal to `accessor.sparse.count` times number of components. The elements have the same component type as the base accessor. The elements are tightly packed. Data **MUST** be aligned following the same rules as the base accessor.
 */
export type AccessorSparseValues = GlTFProperty & {
  /**
   * The index of the bufferView with sparse values. The referenced buffer view **MUST NOT** have its `target` or `byteStride` properties defined.
   */
  bufferView: GlTFId;
  /**
   * The offset relative to the start of the bufferView in bytes.
   */
  byteOffset?: number;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
};
/**
 * A keyframe animation.
 */
export type Animation = GlTFChildOfRootProperty & {
  /**
   * An array of animation channels. An animation channel combines an animation sampler with a target property being animated. Different channels of the same animation **MUST NOT** have the same targets.
   *
   * @minItems 1
   */
  channels: [AnimationChannel, ...AnimationChannel[]];
  /**
   * An array of animation samplers. An animation sampler combines timestamps with a sequence of output values and defines an interpolation algorithm.
   *
   * @minItems 1
   */
  samplers: [AnimationSampler, ...AnimationSampler[]];
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
} & {
  /**
   * An array of animation channels. An animation channel combines an animation sampler with a target property being animated. Different channels of the same animation **MUST NOT** have the same targets.
   *
   * @minItems 1
   */
  channels: [AnimationChannel, ...AnimationChannel[]];
  /**
   * An array of animation samplers. An animation sampler combines timestamps with a sequence of output values and defines an interpolation algorithm.
   *
   * @minItems 1
   */
  samplers: [AnimationSampler, ...AnimationSampler[]];
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
};
/**
 * An animation channel combines an animation sampler with a target property being animated.
 */
export type AnimationChannel = GlTFProperty & {
  /**
   * The index of a sampler in this animation used to compute the value for the target.
   */
  sampler: GlTFId;
  /**
   * The descriptor of the animated property.
   */
  target: AnimationChannelTarget;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
} & {
  /**
   * The index of a sampler in this animation used to compute the value for the target.
   */
  sampler: GlTFId;
  /**
   * The descriptor of the animated property.
   */
  target: AnimationChannelTarget;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
};
/**
 * The descriptor of the animated property.
 */
export type AnimationChannelTarget = GlTFProperty & {
  /**
   * The index of the node to animate. When undefined, the animated object **MAY** be defined by an extension.
   */
  node?: GlTFId;
  /**
   * The name of the node's TRS property to animate, or the `"weights"` of the Morph Targets it instantiates. For the `"translation"` property, the values that are provided by the sampler are the translation along the X, Y, and Z axes. For the `"rotation"` property, the values are a quaternion in the order (x, y, z, w), where w is the scalar. For the `"scale"` property, the values are the scaling factors along the X, Y, and Z axes.
   */
  path: "translation" | "rotation" | "scale" | "weights" | string;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
};
/**
 * An animation sampler combines timestamps with a sequence of output values and defines an interpolation algorithm.
 */
export type AnimationSampler = GlTFProperty & {
  /**
   * The index of an accessor containing keyframe timestamps.
   */
  input: GlTFId;
  /**
   * Interpolation algorithm.
   */
  interpolation?: "LINEAR" | "STEP" | "CUBICSPLINE" | string;
  /**
   * The index of an accessor, containing keyframe output values.
   */
  output: GlTFId;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
} & {
  /**
   * The index of an accessor containing keyframe timestamps.
   */
  input: GlTFId;
  /**
   * Interpolation algorithm.
   */
  interpolation?: "LINEAR" | "STEP" | "CUBICSPLINE" | string;
  /**
   * The index of an accessor, containing keyframe output values.
   */
  output: GlTFId;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
};
/**
 * Metadata about the glTF asset.
 */
export type Asset = GlTFProperty & {
  /**
   * A copyright message suitable for display to credit the content creator.
   */
  copyright?: string;
  /**
   * Tool that generated this glTF model.  Useful for debugging.
   */
  generator?: string;
  /**
   * The glTF version in the form of `<major>.<minor>` that this asset targets.
   */
  version: string;
  /**
   * The minimum glTF version in the form of `<major>.<minor>` that this asset targets. This property **MUST NOT** be greater than the asset version.
   */
  minVersion?: string;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
};
/**
 * A buffer points to binary geometry, animation, or skins.
 */
export type Buffer = GlTFChildOfRootProperty & {
  /**
   * The URI (or IRI) of the buffer.
   */
  uri?: string;
  /**
   * The length of the buffer in bytes.
   */
  byteLength: number;
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
} & {
  /**
   * The URI (or IRI) of the buffer.
   */
  uri?: string;
  /**
   * The length of the buffer in bytes.
   */
  byteLength: number;
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
};
/**
 * A view into a buffer generally representing a subset of the buffer.
 */
export type BufferView = GlTFChildOfRootProperty & {
  /**
   * The index of the buffer.
   */
  buffer: GlTFId;
  /**
   * The offset into the buffer in bytes.
   */
  byteOffset?: number;
  /**
   * The length of the bufferView in bytes.
   */
  byteLength: number;
  /**
   * The stride, in bytes.
   */
  byteStride?: number;
  /**
   * The hint representing the intended GPU buffer type to use with this buffer view.
   */
  target?: 34962 | 34963 | number;
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
} & {
  /**
   * The index of the buffer.
   */
  buffer: GlTFId;
  /**
   * The offset into the buffer in bytes.
   */
  byteOffset?: number;
  /**
   * The length of the bufferView in bytes.
   */
  byteLength: number;
  /**
   * The stride, in bytes.
   */
  byteStride?: number;
  /**
   * The hint representing the intended GPU buffer type to use with this buffer view.
   */
  target?: 34962 | 34963 | number;
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
};
/**
 * A camera's projection.  A node **MAY** reference a camera to apply a transform to place the camera in the scene.
 */
export type Camera = GlTFChildOfRootProperty & {
  /**
   * An orthographic camera containing properties to create an orthographic projection matrix. This property **MUST NOT** be defined when `perspective` is defined.
   */
  orthographic?: CameraOrthographic;
  /**
   * A perspective camera containing properties to create a perspective projection matrix. This property **MUST NOT** be defined when `orthographic` is defined.
   */
  perspective?: CameraPerspective;
  /**
   * Specifies if the camera uses a perspective or orthographic projection.
   */
  type: "perspective" | "orthographic" | string;
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
} & {
  /**
   * An orthographic camera containing properties to create an orthographic projection matrix. This property **MUST NOT** be defined when `perspective` is defined.
   */
  orthographic?: CameraOrthographic;
  /**
   * A perspective camera containing properties to create a perspective projection matrix. This property **MUST NOT** be defined when `orthographic` is defined.
   */
  perspective?: CameraPerspective;
  /**
   * Specifies if the camera uses a perspective or orthographic projection.
   */
  type: "perspective" | "orthographic" | string;
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
};
/**
 * An orthographic camera containing properties to create an orthographic projection matrix.
 */
export type CameraOrthographic = GlTFProperty & {
  /**
   * The floating-point horizontal magnification of the view. This value **MUST NOT** be equal to zero. This value **SHOULD NOT** be negative.
   */
  xmag: number;
  /**
   * The floating-point vertical magnification of the view. This value **MUST NOT** be equal to zero. This value **SHOULD NOT** be negative.
   */
  ymag: number;
  /**
   * The floating-point distance to the far clipping plane. This value **MUST NOT** be equal to zero. `zfar` **MUST** be greater than `znear`.
   */
  zfar: number;
  /**
   * The floating-point distance to the near clipping plane.
   */
  znear: number;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
};
/**
 * A perspective camera containing properties to create a perspective projection matrix.
 */
export type CameraPerspective = GlTFProperty & {
  /**
   * The floating-point aspect ratio of the field of view.
   */
  aspectRatio?: number;
  /**
   * The floating-point vertical field of view in radians. This value **SHOULD** be less than Ï€.
   */
  yfov: number;
  /**
   * The floating-point distance to the far clipping plane.
   */
  zfar?: number;
  /**
   * The floating-point distance to the near clipping plane.
   */
  znear: number;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
};
/**
 * Image data used to create a texture. Image **MAY** be referenced by an URI (or IRI) or a buffer view index.
 */
export type Image = GlTFChildOfRootProperty & {
  /**
   * The URI (or IRI) of the image.
   */
  uri?: string;
  /**
   * The image's media type. This field **MUST** be defined when `bufferView` is defined.
   */
  mimeType?: "image/jpeg" | "image/png" | string;
  /**
   * The index of the bufferView that contains the image. This field **MUST NOT** be defined when `uri` is defined.
   */
  bufferView?: GlTFId;
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
} & (
    | {
        [k: string]: unknown;
      }
    | {
        [k: string]: unknown;
      }
  ) & {
    /**
     * The URI (or IRI) of the image.
     */
    uri?: string;
    /**
     * The image's media type. This field **MUST** be defined when `bufferView` is defined.
     */
    mimeType?: "image/jpeg" | "image/png" | string;
    /**
     * The index of the bufferView that contains the image. This field **MUST NOT** be defined when `uri` is defined.
     */
    bufferView?: GlTFId;
    name?: unknown;
    extensions?: unknown;
    extras?: unknown;
    [k: string]: unknown;
  } & (
    | {
        [k: string]: unknown;
      }
    | {
        [k: string]: unknown;
      }
  );
/**
 * The material appearance of a primitive.
 */
export type Material = GlTFChildOfRootProperty & {
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  /**
   * A set of parameter values that are used to define the metallic-roughness material model from Physically Based Rendering (PBR) methodology. When undefined, all the default values of `pbrMetallicRoughness` **MUST** apply.
   */
  pbrMetallicRoughness?: MaterialPBRMetallicRoughness;
  /**
   * The tangent space normal texture.
   */
  normalTexture?: MaterialNormalTextureInfo;
  /**
   * The occlusion texture.
   */
  occlusionTexture?: MaterialOcclusionTextureInfo;
  /**
   * The emissive texture.
   */
  emissiveTexture?: TextureInfo;
  /**
   * The factors for the emissive color of the material.
   *
   * @minItems 3
   * @maxItems 3
   */
  emissiveFactor?: [number, number, number];
  /**
   * The alpha rendering mode of the material.
   */
  alphaMode?: "OPAQUE" | "MASK" | "BLEND" | string;
  /**
   * The alpha cutoff value of the material.
   */
  alphaCutoff?: number;
  /**
   * Specifies whether the material is double sided.
   */
  doubleSided?: boolean;
  [k: string]: unknown;
} & {
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  /**
   * A set of parameter values that are used to define the metallic-roughness material model from Physically Based Rendering (PBR) methodology. When undefined, all the default values of `pbrMetallicRoughness` **MUST** apply.
   */
  pbrMetallicRoughness?: MaterialPBRMetallicRoughness;
  /**
   * The tangent space normal texture.
   */
  normalTexture?: MaterialNormalTextureInfo;
  /**
   * The occlusion texture.
   */
  occlusionTexture?: MaterialOcclusionTextureInfo;
  /**
   * The emissive texture.
   */
  emissiveTexture?: TextureInfo;
  /**
   * The factors for the emissive color of the material.
   *
   * @minItems 3
   * @maxItems 3
   */
  emissiveFactor?: [number, number, number];
  /**
   * The alpha rendering mode of the material.
   */
  alphaMode?: "OPAQUE" | "MASK" | "BLEND" | string;
  /**
   * The alpha cutoff value of the material.
   */
  alphaCutoff?: number;
  /**
   * Specifies whether the material is double sided.
   */
  doubleSided?: boolean;
  [k: string]: unknown;
};
/**
 * A set of parameter values that are used to define the metallic-roughness material model from Physically-Based Rendering (PBR) methodology.
 */
export type MaterialPBRMetallicRoughness = GlTFProperty & {
  /**
   * The factors for the base color of the material.
   *
   * @minItems 4
   * @maxItems 4
   */
  baseColorFactor?: [number, number, number, number];
  /**
   * The base color texture.
   */
  baseColorTexture?: TextureInfo;
  /**
   * The factor for the metalness of the material.
   */
  metallicFactor?: number;
  /**
   * The factor for the roughness of the material.
   */
  roughnessFactor?: number;
  /**
   * The metallic-roughness texture.
   */
  metallicRoughnessTexture?: TextureInfo;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
};
/**
 * Reference to a texture.
 */
export type TextureInfo = GlTFProperty & {
  /**
   * The index of the texture.
   */
  index: GlTFId;
  /**
   * The set index of texture's TEXCOORD attribute used for texture coordinate mapping.
   */
  texCoord?: number;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
} & {
  /**
   * The index of the texture.
   */
  index: GlTFId;
  /**
   * The set index of texture's TEXCOORD attribute used for texture coordinate mapping.
   */
  texCoord?: number;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
} & {
  /**
   * The index of the texture.
   */
  index: GlTFId;
  /**
   * The set index of texture's TEXCOORD attribute used for texture coordinate mapping.
   */
  texCoord?: number;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
} & {
  /**
   * The index of the texture.
   */
  index: GlTFId;
  /**
   * The set index of texture's TEXCOORD attribute used for texture coordinate mapping.
   */
  texCoord?: number;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
} & {
  /**
   * The index of the texture.
   */
  index: GlTFId;
  /**
   * The set index of texture's TEXCOORD attribute used for texture coordinate mapping.
   */
  texCoord?: number;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
};
export type MaterialNormalTextureInfo = TextureInfo & {
  index?: unknown;
  texCoord?: unknown;
  /**
   * The scalar parameter applied to each normal vector of the normal texture.
   */
  scale?: number;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
};
export type MaterialOcclusionTextureInfo = TextureInfo & {
  index?: unknown;
  texCoord?: unknown;
  /**
   * A scalar multiplier controlling the amount of occlusion applied.
   */
  strength?: number;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
};
/**
 * A set of primitives to be rendered.  Its global transform is defined by a node that references it.
 */
export type Mesh = GlTFChildOfRootProperty & {
  /**
   * An array of primitives, each defining geometry to be rendered.
   *
   * @minItems 1
   */
  primitives: [MeshPrimitive, ...MeshPrimitive[]];
  /**
   * Array of weights to be applied to the morph targets. The number of array elements **MUST** match the number of morph targets.
   *
   * @minItems 1
   */
  weights?: [number, ...number[]];
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
} & {
  /**
   * An array of primitives, each defining geometry to be rendered.
   *
   * @minItems 1
   */
  primitives: [MeshPrimitive, ...MeshPrimitive[]];
  /**
   * Array of weights to be applied to the morph targets. The number of array elements **MUST** match the number of morph targets.
   *
   * @minItems 1
   */
  weights?: [number, ...number[]];
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
};
/**
 * Geometry to be rendered with the given material.
 */
export type MeshPrimitive = GlTFProperty & {
  /**
   * A plain JSON object, where each key corresponds to a mesh attribute semantic and each value is the index of the accessor containing attribute's data.
   */
  attributes: {
    [k: string]: GlTFId;
  };
  /**
   * The index of the accessor that contains the vertex indices.
   */
  indices?: GlTFId;
  /**
   * The index of the material to apply to this primitive when rendering.
   */
  material?: GlTFId;
  /**
   * The topology type of primitives to render.
   */
  mode?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | number;
  /**
   * An array of morph targets.
   *
   * @minItems 1
   */
  targets?: [
    {
      [k: string]: GlTFId;
    },
    ...{
      [k: string]: GlTFId;
    }[]
  ];
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
} & {
  /**
   * A plain JSON object, where each key corresponds to a mesh attribute semantic and each value is the index of the accessor containing attribute's data.
   */
  attributes: {
    [k: string]: GlTFId;
  };
  /**
   * The index of the accessor that contains the vertex indices.
   */
  indices?: GlTFId;
  /**
   * The index of the material to apply to this primitive when rendering.
   */
  material?: GlTFId;
  /**
   * The topology type of primitives to render.
   */
  mode?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | number;
  /**
   * An array of morph targets.
   *
   * @minItems 1
   */
  targets?: [
    {
      [k: string]: GlTFId;
    },
    ...{
      [k: string]: GlTFId;
    }[]
  ];
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
};
/**
 * A node in the node hierarchy.  When the node contains `skin`, all `mesh.primitives` **MUST** contain `JOINTS_0` and `WEIGHTS_0` attributes.  A node **MAY** have either a `matrix` or any combination of `translation`/`rotation`/`scale` (TRS) properties. TRS properties are converted to matrices and postmultiplied in the `T * R * S` order to compose the transformation matrix; first the scale is applied to the vertices, then the rotation, and then the translation. If none are provided, the transform is the identity. When a node is targeted for animation (referenced by an animation.channel.target), `matrix` **MUST NOT** be present.
 */
export type Node = GlTFChildOfRootProperty & {
  /**
   * The index of the camera referenced by this node.
   */
  camera?: GlTFId;
  /**
   * The indices of this node's children.
   *
   * @minItems 1
   */
  children?: [GlTFId, ...GlTFId[]];
  /**
   * The index of the skin referenced by this node.
   */
  skin?: GlTFId;
  /**
   * A floating-point 4x4 transformation matrix stored in column-major order.
   *
   * @minItems 16
   * @maxItems 16
   */
  matrix?: [
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number
  ];
  /**
   * The index of the mesh in this node.
   */
  mesh?: GlTFId;
  /**
   * The node's unit quaternion rotation in the order (x, y, z, w), where w is the scalar.
   *
   * @minItems 4
   * @maxItems 4
   */
  rotation?: [number, number, number, number];
  /**
   * The node's non-uniform scale, given as the scaling factors along the x, y, and z axes.
   *
   * @minItems 3
   * @maxItems 3
   */
  scale?: [number, number, number];
  /**
   * The node's translation along the x, y, and z axes.
   *
   * @minItems 3
   * @maxItems 3
   */
  translation?: [number, number, number];
  /**
   * The weights of the instantiated morph target. The number of array elements **MUST** match the number of morph targets of the referenced mesh. When defined, `mesh` **MUST** also be defined.
   *
   * @minItems 1
   */
  weights?: [number, ...number[]];
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
} & {
  /**
   * The index of the camera referenced by this node.
   */
  camera?: GlTFId;
  /**
   * The indices of this node's children.
   *
   * @minItems 1
   */
  children?: [GlTFId, ...GlTFId[]];
  /**
   * The index of the skin referenced by this node.
   */
  skin?: GlTFId;
  /**
   * A floating-point 4x4 transformation matrix stored in column-major order.
   *
   * @minItems 16
   * @maxItems 16
   */
  matrix?: [
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number
  ];
  /**
   * The index of the mesh in this node.
   */
  mesh?: GlTFId;
  /**
   * The node's unit quaternion rotation in the order (x, y, z, w), where w is the scalar.
   *
   * @minItems 4
   * @maxItems 4
   */
  rotation?: [number, number, number, number];
  /**
   * The node's non-uniform scale, given as the scaling factors along the x, y, and z axes.
   *
   * @minItems 3
   * @maxItems 3
   */
  scale?: [number, number, number];
  /**
   * The node's translation along the x, y, and z axes.
   *
   * @minItems 3
   * @maxItems 3
   */
  translation?: [number, number, number];
  /**
   * The weights of the instantiated morph target. The number of array elements **MUST** match the number of morph targets of the referenced mesh. When defined, `mesh` **MUST** also be defined.
   *
   * @minItems 1
   */
  weights?: [number, ...number[]];
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
};
/**
 * Texture sampler properties for filtering and wrapping modes.
 */
export type Sampler = GlTFChildOfRootProperty & {
  /**
   * Magnification filter.
   */
  magFilter?: 9728 | 9729 | number;
  /**
   * Minification filter.
   */
  minFilter?: 9728 | 9729 | 9984 | 9985 | 9986 | 9987 | number;
  /**
   * S (U) wrapping mode.
   */
  wrapS?: 33071 | 33648 | 10497 | number;
  /**
   * T (V) wrapping mode.
   */
  wrapT?: 33071 | 33648 | 10497 | number;
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
} & {
  /**
   * Magnification filter.
   */
  magFilter?: 9728 | 9729 | number;
  /**
   * Minification filter.
   */
  minFilter?: 9728 | 9729 | 9984 | 9985 | 9986 | 9987 | number;
  /**
   * S (U) wrapping mode.
   */
  wrapS?: 33071 | 33648 | 10497 | number;
  /**
   * T (V) wrapping mode.
   */
  wrapT?: 33071 | 33648 | 10497 | number;
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
};
/**
 * The root nodes of a scene.
 */
export type Scene = GlTFChildOfRootProperty & {
  /**
   * The indices of each root node.
   *
   * @minItems 1
   */
  nodes?: [GlTFId, ...GlTFId[]];
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
} & {
  /**
   * The indices of each root node.
   *
   * @minItems 1
   */
  nodes?: [GlTFId, ...GlTFId[]];
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
};
/**
 * Joints and matrices defining a skin.
 */
export type Skin = GlTFChildOfRootProperty & {
  /**
   * The index of the accessor containing the floating-point 4x4 inverse-bind matrices.
   */
  inverseBindMatrices?: GlTFId;
  /**
   * The index of the node used as a skeleton root.
   */
  skeleton?: GlTFId;
  /**
   * Indices of skeleton nodes, used as joints in this skin.
   *
   * @minItems 1
   */
  joints: [GlTFId, ...GlTFId[]];
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
} & {
  /**
   * The index of the accessor containing the floating-point 4x4 inverse-bind matrices.
   */
  inverseBindMatrices?: GlTFId;
  /**
   * The index of the node used as a skeleton root.
   */
  skeleton?: GlTFId;
  /**
   * Indices of skeleton nodes, used as joints in this skin.
   *
   * @minItems 1
   */
  joints: [GlTFId, ...GlTFId[]];
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
};
/**
 * A texture and its sampler.
 */
export type Texture = GlTFChildOfRootProperty & {
  /**
   * The index of the sampler used by this texture. When undefined, a sampler with repeat wrapping and auto filtering **SHOULD** be used.
   */
  sampler?: GlTFId;
  /**
   * The index of the image used by this texture. When undefined, an extension or other mechanism **SHOULD** supply an alternate texture source, otherwise behavior is undefined.
   */
  source?: GlTFId;
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
} & {
  /**
   * The index of the sampler used by this texture. When undefined, a sampler with repeat wrapping and auto filtering **SHOULD** be used.
   */
  sampler?: GlTFId;
  /**
   * The index of the image used by this texture. When undefined, an extension or other mechanism **SHOULD** supply an alternate texture source, otherwise behavior is undefined.
   */
  source?: GlTFId;
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
};

export interface GlTFProperty {
  extensions?: Extension;
  extras?: Extras;
  [k: string]: unknown;
}
/**
 * JSON object with extension-specific objects.
 */
export interface Extension {
  [k: string]: {
    [k: string]: unknown;
  };
}
/**
 * Application-specific data.
 */
export interface Extras {
  [k: string]: unknown;
}
